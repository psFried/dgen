#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
use interpreter::ast::{self, process_string_escapes};
use generator::GeneratorType;
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar;

Comment: String = {
    <s:r"#.*"> => s.trim()[1..].trim().to_owned()
}

Comma<E>: Vec<E> = {
    <v0:(<E> ",")*> <e1:E?> => v0.into_iter().chain(e1).collect()
};

BooleanLiteral: bool = {
    "true" => true,
    "false" => false
}

IntLiteral: u64 = {
    <s:r"[0-9]+"> => u64::from_str(s).unwrap()
};

SignedIntLiteral: i64 = {
    <s:r"[-+][0-9]+"> => i64::from_str(s).unwrap()
}

DecimalLiteral: f64 = {
    <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap()
};

StringLiteral: String = {
    //<s:r#""([^"\\]*(\\.[^"\\]*)*)""#> => s[1..s.len() - 1].replace(r#"\""#, r#"""#).replace("\\n", "\n")
    <s:r#""([^"\\]*(\\.[^"\\]*)*)""#> =>? {
        process_string_escapes(&s[1..(s.len() - 1)]).map_err(|e| {
            eprintln!("invalid string literal: {}", e);
            ParseError::User { error: e}
        })
    }
};

CharLiteral: char = {
    <c:r"'[^']+'"> =>? {
        process_string_escapes(&c[1..(c.len() - 1)]).map_err(|e| {
            eprintln!("invalid char literal: {}", e);
            ParseError::User { error: e}
        }).map(|s| s.chars().next().unwrap())
    }
}

pub Expr: ast::Expr = {
    <c:Comment*> <l:CharLiteral> => ast::Expr::CharLiteral(l),
    <c:Comment*> <b:BooleanLiteral> => ast::Expr::BooleanLiteral(b),
    <c:Comment*> <s:StringLiteral> => ast::Expr::StringLiteral(s),
    <c:Comment*> <i:IntLiteral> => ast::Expr::IntLiteral(i),
    <c:Comment*> <i:SignedIntLiteral> => ast::Expr::SignedIntLiteral(i),
    <c:Comment*> <d:DecimalLiteral> => ast::Expr::DecimalLiteral(d),
    <c:Comment*> <f:FunctionCall> => ast::Expr::Function(f)
};

FunctionCall: ast::FunctionCall = {
    <n:FunctionName>"(" <a:Comma<Expr>> ")" => ast::FunctionCall { function_name: n, args: a, mapper: None },
    <n:FunctionName> => ast::FunctionCall { function_name: n, args: Vec::new(), mapper: None },
    <n:FunctionName>"(" <a:Comma<Expr>> ")" "{" <ma:FunctionName> "->" <m:Expr> "}" => {
        ast::FunctionCall {
            function_name: n, 
            args: a, 
            mapper: Some(Box::new(ast::FunctionMapper {
                arg_name: ma,
                mapper_body: m,
            }))
        }
    },
    <n:FunctionName> "{" <ma:FunctionName> "->" <m:Expr> "}" => {
        ast::FunctionCall {
            function_name: n, 
            args: Vec::new(), 
            mapper: Some(Box::new(ast::FunctionMapper {
                arg_name: ma,
                mapper_body: m,
            }))
        }
    }
};

FunctionName: String = {
    <s:r"[a-zA-Z]+\w*"> => s.to_owned()
};

GenType: GeneratorType = {
    "Uint" => GeneratorType::UnsignedInt,
    "String" => GeneratorType::String,
    "Int" => GeneratorType::SignedInt,
    "Boolean" => GeneratorType::Boolean,
    "Float" => GeneratorType::Decimal,
    "Char" => GeneratorType::Char
}

MacroArg: ast::MacroArgument = {
    <n:FunctionName> ":" <t:GenType>  => ast::MacroArgument {name: n, arg_type: t}
}

DefineMacro: ast::MacroDef = {
    <c:Comment*> "def" <n:FunctionName> "(" <args:Comma<MacroArg>> ")" "=" <e:Expr> ";" => ast::MacroDef { name: n, args: args, body: e, doc_comments: c }
}


pub Program: ast::Program = {
    <m:DefineMacro*> <e:Expr> => ast::Program {assignments: m, expr: e }
}

pub Library: Vec<ast::MacroDef> = {
    <m:DefineMacro*> => m
}